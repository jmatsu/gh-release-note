#!/usr/bin/env bash

set -Eeuo pipefail
trap cleanup SIGINT SIGTERM ERR EXIT

readonly OUTPUT_DIR="$(mktemp -d)"

usage() {
  cat <<EOF >&2
Usage:
  gh release-note -h
  gh release-note -R OWNER/REPO -B BRANCH [-S SINCE] [-U UNTIL] [--tag-prefix TAG_PREFIX]

A gh extension to generate release notes from pull requests merged between two git refs.

Available options:
-h, --help
                  Print this help and exit
-R, --repo OWNER/REPO
                  Select another repository using the OWNER/REPO format
-B, --base BRANCH
                  The branch name that the pull requests have been merged into
-S, --since DATE
                  The date from the tag or which the pull request have been merged into the base branch
-U, --until DATE
                  The date until the tag or which the pull requests have been merged into the base branch
--tag-prefix TAG_PREFIX
                  The prefix of the tag name to filter tag names
EOF
  exit
}

cleanup() {
  trap - SIGINT SIGTERM ERR EXIT

  rm -fr "${OUTPUT_DIR}"
}

initialize_colors() {
  NOFORMAT='' RED='' GREEN='' ORANGE='' BLUE='' PURPLE='' CYAN='' YELLOW=''
}

setup_colors() {
  if [[ -t 2 ]] && [[ -z "${NO_COLOR-}" ]] && [[ "${TERM-}" != "dumb" ]]; then
    NOFORMAT='\033[0m' RED='\033[0;31m' GREEN='\033[0;32m' ORANGE='\033[0;33m' BLUE='\033[0;34m' PURPLE='\033[0;35m' CYAN='\033[0;36m' YELLOW='\033[1;33m'
  fi
}

msg() {
  echo >&2 -e "${1-}"
}

info() {
  msg "${GREEN}$1${NOFORMAT}"
}

warn() {
  msg "${YELLOW}$1${NOFORMAT}"
}

err() {
  msg "${RED}$1${NOFORMAT}"
}

die() {
  err "${1-}"
  exit "${2-1}"
}

parse_params() {
  repo=''
  base=''
  since=''
  until=''
  tag_prefix=''

  _VERBOSE_=''

  while :; do
    case "${1-}" in
    -h | --help) usage ;;
    -v | --verbose) _VERBOSE_=1 ;;
    --no-color) NO_COLOR=1 ;;
    -R | --repo)
      repo="${2-}"
      shift
      ;;
    -B | --base)
      base="${2-}"
      shift
      ;;
    -S | --since)
      since="${2-}"
      shift
      ;;
    -U | --until)
      until="${2-}"
      shift
      ;;
    --tag-prefix)
      tag_prefix="${2-}"
      shift
      ;;
    -?*) die "Unknown option: $1" ;;
    *) break ;;
    esac

    shift
  done

  [[ -z "${base-}" ]] && die "Missing required parameter: -B, --base <branch name>"

  if [[ -n "${since-}" ]] && [[ "${since-}" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]]; then
    die "Invalid date format for -S, --since: ${since-}"
  fi

  if [[ -n "${until-}" ]] && [[ "${until-}" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]]; then
    die "Invalid date format for -U, --until: ${until-}"
  fi

  return 0
}

# read the cache or download tags in the repository
download_tags() {
  local -r tags_cache="${OUTPUT_DIR}/tags.txt"

  local -r repo="${1-}" tag_prefix="${2-}"

  local jq_args=()

  # api returns tags in created_at desc order
  if [[ -n "${tag_prefix-}" ]]; then
    jq_args+=("--arg" "tag_prefix" "$tag_prefix")
    
    # Don't expand $-prefix variables as shell variables
    # shellcheck disable=SC2016
    jq_args+=('[.[] | select(.ref | startswith("refs/tags/" + $tag_prefix))] | reverse')
  else
    jq_args+=('reverse')
  fi

  {
    if [[ -f "${tags_cache}" ]]; then
      cat "${tags_cache}"
    else
      gh api -X GET "/repos/$repo/git/refs/tags" | tee "${tags_cache}"
    fi
  } | jq "${jq_args[@]}"
}

# format the tag objects for filter commands
read_or_fetch_for_selection() {
  local repo="${1-}" tag_prefix="${2-}"
  download_tags "$repo" "$tag_prefix" | jq -r '.[] | .ref' | sed -e 's#refs/tags/##'
}

# resolve the author date of the commit that associates with the tag
resolve_date_from_tag() {
  local -r repo="${1-}" tag_name="${2-}"

  local -r sha="$(download_tags "$repo" | jq -r --arg tag_name "refs/tags/$tag_name" '.[] | select(.ref == $tag_name) | .object.sha')"

  gh api "/repos/$repo/git/commits/$sha" --jq '.author.date' | sed -e 's/T.*$//'
}

initialize_colors
parse_params "$@"
setup_colors

# TODO relax the constraint for commands to filter outputs.
if ! type fzf >/dev/null 2>&1; then
  err "fzf command not found"
  exit 1
fi

# TODO allow the limit to be configurable
gh_pr_list_opts=("--limit" "100" "--base" "$base")

if [[ -n "${repo-}" ]]; then
  gh_pr_list_opts+=("--repo" "$repo")
fi

if [[ -z "${since-}" ]]; then
  since_tag_name="$(read_or_fetch_for_selection "$repo" "$tag_prefix" | fzf)"

  if [[ -z "${since_tag_name-}" ]]; then
    die "No tag has been selected"
  fi

  since="$(resolve_date_from_tag "$repo" "$since_tag_name")"
fi

if [[ -z "${until-}" ]]; then
  until_tag_name="$(read_or_fetch_for_selection "$repo" "$tag_prefix" | fzf)"

  if [[ -z "${until_tag_name-}" ]]; then
    die "No tag has been selected"
  fi

  until="$(resolve_date_from_tag "$repo" "$until_tag_name")"
fi

gh_pr_list_opts+=("--search" "merged:$since..$until")

# TODO allow the format to be configurable
gh pr list "${gh_pr_list_opts[@]}" --json 'number,title,author' --jq '.[] | "- " + "#" + (.number | tostring) + " " + .title + " by " + .author.login'
